# 設計メモ.md

* パターンマッチを使う
  * これにより、言語処理系を命令に対するフィルタとして設計できる
  * 最終的には同じ設計だが、これを使うことで**密結合にすべき箇所と疎結合にすべき箇所を見定められる**
  * 逆に言えば、オブジェクト指向の弱点は小規模なソフトウェアでも疎結合で設計することを強制されること
* defaultが強制されることで、入力内容がなんでもよいことを受け入れられる
  * オブジェクト指向での設計は冗長であると感じる
* 小さめの規模のソフトウェアであれば、パターンマッチを使ったほうが便利
* 疎結合にすべき箇所とは、**飛んでくるデータの内容がわからない箇所である**

## もともとの懸念
* 中身のわからない値が渡されてきた場合、基本の挙動は「そのオブジェクト自身に挙動を喋らせる」こと
* 共通のインタフェースを定め、それに沿って挙動を喋らせることで様々な値に対応できるようにすることをポリモーフィズムという
* パターンマッチを利用すると、受け取るオブジェクトに依存したコードが書かれることになるのでは？

## パターンマッチング
参考：[Ruby2\.7の\(実験的\)新機能「パターンマッチ」で遊ぶ \- メドピア開発者ブログ](https://tech.medpeer.co.jp/entry/2019/05/13/090000)
参考：[Pattern matching \- New feature in Ruby 2\.7 \- Speaker Deck](https://speakerdeck.com/k_tsj/pattern-matching-new-feature-in-ruby-2-dot-7)

### 概要
* case/when + multiple assignment
* if/unlessによるguardが可能

### Value Pattern
===でマッチさせる
つまり、case/whenと同じ

Integerだけじゃなく、RangeやClassもいける

### Variable Pattern
任意の値にマッチし、ローカル変数にバインドする

つまり、multiple assignmentだけを使っている

### Alternative Pattern
これは | で区切ることで複数のパターンとマッチさせられる

### As Pattern
マッチした値を任意の変数に格納する

### Array Pattern
* ClassName === でtrueが返る
* 検査対象オブジェクトのdeconstructが配列を返す
* deconstructが返した配列と指定パターンがマッチ

独自にdecontrustメソッドを定義することで、パターンマッチができるようになる

### Hash Pattern
* ClassName === でtrueが返る
* 検査対象オブジェクトのdeconstruct_keysがハッシュを返す
* deconstruct_keysが返したハッシュと指定パターンがマッチ 

